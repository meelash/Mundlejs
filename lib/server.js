// Generated by CoffeeScript 1.3.3
(function() {
  var Mundle, MundleError, MundleFile, addPackageCache, basePath, checkPermission, defaultPackageMain, fileCache, findRequires, fs, getPackageCache, hasOwnProperty, indexCache, loadedPlugins, mundlesPath, packageCache, parent, path, pkgCache, processWithPlugins, readPackage, requestHandler, serverRequire, tryFile, url, versionCache,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require('fs');

  path = require('path');

  url = require('url');

  findRequires = require('find-requires');

  pkgCache = {};

  indexCache = {};

  fileCache = {};

  versionCache = {};

  packageCache = {};

  basePath = '/';

  mundlesPath = path.resolve('./mundles');

  loadedPlugins = {};

  defaultPackageMain = 'index.js';

  hasOwnProperty = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };

  Mundle = (function() {

    function Mundle(loadedModules) {
      this.loaded = loadedModules;
      this.queue = 0;
    }

    Mundle.prototype.require = function(file, callback) {
      var errors, results;
      results = {};
      errors = null;
      return this.readAndParseFile(file, function(err, file, contents) {
        var safePath;
        safePath = file.getClientPath();
        results[safePath] = contents;
        if (err) {
          (errors || (errors = {}))[safePath] = err;
          err.path = file.getRelPath();
        }
        if (this.queue === 0) {
          return callback(errors, results);
        }
      });
    };

    Mundle.prototype.readAndParseFile = function(file, callback) {
      var _this = this;
      if (this.loaded[file.getClientPath()]) {
        return;
      }
      this.queue++;
      try {
        return file.getContents(function(error, contents) {
          if (error == null) {
            _this.loaded[file.getClientPath()] = true;
            _this.findAndLoadSyncRequires(file, contents, callback);
          }
          _this.queue--;
          return callback.call(_this, error, file, contents);
        });
      } catch (error) {
        this.queue--;
        return callback.call(this, error, file, '');
      }
    };

    Mundle.prototype.findAndLoadSyncRequires = function(file, contents, callback) {
      var dependencies, dependency, unprocessedPath, _i, _len, _name, _results;
      dependencies = indexCache[_name = file.getClientPath()] || (indexCache[_name] = findRequires(contents, {
        raw: true
      }));
      _results = [];
      for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
        dependency = dependencies[_i];
        if ((unprocessedPath = dependency.value) != null) {
          file = new MundleFile({
            relPath: unprocessedPath,
            parent: file
          });
          _results.push(this.readAndParseFile(file, callback));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Mundle;

  })();

  MundleFile = (function() {
    var basePrefix, mundlePrefix;

    function MundleFile(_arg) {
      this.clientPath = _arg.clientPath, this.relPath = _arg.relPath, this.parent = _arg.parent;
      if (!((this.clientPath != null) || (this.relPath != null))) {
        console.error("MundleFile needs a path");
        return null;
      }
    }

    MundleFile.prototype.getRelPath = function() {
      return this.relPath || this.clientPath;
    };

    basePrefix = '/b';

    mundlePrefix = '/m';

    MundleFile.prototype.getClientPath = function() {
      var clientPath, component, components, match, relPath, subDir, version;
      if (this.clientPath != null) {
        return this.clientPath;
      }
      relPath = this.getRelPath();
      if (/^(\.|\.\.)?\//.test(relPath)) {
        if (/^\//.test(relPath)) {
          return this.clientPath = "" + basePrefix + relPath;
        } else {
          components = relPath.split('/');
          clientPath = parent(this.parent.getClientPath());
          while (components.length > 0) {
            switch (component = (components.splice(0, 1))[0]) {
              case '..':
                clientPath = parent(clientPath);
                break;
              case '.':
                break;
              default:
                clientPath += "/" + component;
            }
          }
          return this.clientPath = clientPath;
        }
      } else {
        match = /^(.*?)((@)(.*?))?(\/.*)?$/.exec(relPath);
        version = match[4] || versionCache[match[1]] || '0.0.0';
        clientPath = "" + mundlePrefix + "/" + match[1] + "/" + version;
        if ((subDir = match[5]) != null) {
          clientPath += subDir;
        }
        return this.clientPath = clientPath;
      }
    };

    MundleFile.prototype.getAbsPath = function(callback) {
      var clientPath, error, gotAbsPath, match, name, packagePath, str, version,
        _this = this;
      if (this.absPath != null) {
        return callback(null, this.absPath);
      }
      gotAbsPath = function(absPath, callback) {
        try {
          checkPermission(absPath);
          return callback(null, _this.absPath = absPath);
        } catch (error) {
          return callback(error);
        }
      };
      clientPath = this.getClientPath();
      if (/^\/b\//.test(clientPath)) {
        return gotAbsPath(path.join(basePath, clientPath.slice(3)), callback);
      } else if (/^\/m\//.test(clientPath)) {
        match = /^\/m\/(.*?)\/(.*?)(\/.*)?$/.exec(clientPath);
        str = match[0], name = match[1], version = match[2], clientPath = match[3];
        version = version.replace('0.0.0', 'latest');
        if (clientPath != null) {
          return gotAbsPath(path.join(mundlesPath, name, clientPath), callback);
        } else {
          packagePath = path.join(mundlesPath, name);
          return readPackage(packagePath, function(error, pkg) {
            var filename;
            if (error) {
              return callback(error);
            } else {
              if (pkg.main == null) {
                pkg.main = defaultPackageMain;
              }
              filename = path.resolve(packagePath, pkg.main);
              return tryFile(filename, function(error, absPath) {
                if (!absPath) {
                  return callback(new MundleError({
                    message: 'Unable to read file'
                  }));
                } else {
                  return gotAbsPath(absPath, callback);
                }
              });
            }
          });
        }
      } else {
        error = new MundleError({
          message: 'Incorrectly formed request. Missing request type (/b or /m)'
        });
        return callback(error);
      }
    };

    MundleFile.prototype.getContents = function(callback) {
      var _this = this;
      if (this.contents != null) {
        return callback(null, this.contents);
      }
      if ((this.contents = fileCache[this.getClientPath()]) != null) {
        return callback(null, this.contents);
      }
      return this.getAbsPath(function(error, absPath) {
        if (error != null) {
          return callback(error);
        } else {
          return fs.readFile(absPath, 'utf8', function(error, contents) {
            var code, errno, syscall;
            if (error != null) {
              errno = error.errno, code = error.code, syscall = error.syscall;
              console.error(error, 'at getContents');
              error = new MundleError({
                message: 'Unable to read file',
                errno: errno,
                code: code,
                syscall: syscall
              });
            }
            return callback(error, _this.contents = fileCache[_this.getClientPath()] = processWithPlugins(absPath, contents));
          });
        }
      });
    };

    return MundleFile;

  })();

  MundleError = (function(_super) {

    __extends(MundleError, _super);

    function MundleError(options) {
      var property, value;
      for (property in options) {
        if (!__hasProp.call(options, property)) continue;
        value = options[property];
        this[property] = value;
      }
      MundleError.__super__.constructor.call(this);
    }

    return MundleError;

  })(Error);

  readPackage = function(requestPath, callback) {
    var jsonPath;
    if (hasOwnProperty(packageCache, requestPath)) {
      return callback(void 0, packageCache[requestPath]);
    }
    jsonPath = path.resolve(requestPath, 'package.json');
    return fs.exists(jsonPath, function(exists) {
      var pkg;
      if (!exists) {
        pkg = packageCache[requestPath] = {};
        return callback(void 0, pkg);
      }
      return fs.readFile(jsonPath, 'utf8', function(error, json) {
        var code, errno, syscall;
        if (error != null) {
          errno = error.errno, code = error.code, syscall = error.syscall;
          console.error(error, 'at readPackage');
          return callback(new MundleError({
            message: 'Error reading mundle package.json',
            errno: errno,
            code: code,
            syscall: syscall
          }));
        }
        try {
          pkg = packageCache[requestPath] = JSON.parse(json);
        } catch (e) {
          e.path = jsonPath;
          e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
          error = new MundleError(e);
        }
        return callback(error, pkg);
      });
    });
  };

  tryFile = function(requestPath, callback) {
    return fs.stat(requestPath, function(error, stats) {
      if (stats && !stats.isDirectory()) {
        return fs.realpath(requestPath, callback);
      }
      return callback(error, false);
    });
  };

  checkPermission = function(filePath) {
    if (!/^\.\.\//.test(path.relative(mundlesPath, filePath))) {
      return;
    }
    if (!/^\.\.\//.test(path.relative(basePath, filePath))) {
      return;
    }
    throw new MundleError({
      message: 'Attempt to access a file in an unauthorized location'
    });
  };

  parent = function(path) {
    var ar;
    ar = path.split('/');
    if (ar[0] !== '') {
      console.error('parent only accepts absolute paths');
    }
    if (ar[1] === 'm') {
      if (ar.length < 5) {
        return ar.join('/');
      }
    } else if (ar.length < 3) {
      return ar.join('/');
    }
    ar.pop();
    return ar.join('/');
  };

  processWithPlugins = function(filePath, contents) {
    var compiler, extension;
    extension = (path.extname(filePath)).slice(1);
    if ((compiler = loadedPlugins[extension]) != null) {
      contents = compiler(contents);
    }
    return contents;
  };

  getPackageCache = function(filePath, clientCacheDiff) {
    var index;
    filePath = filePath.getClientPath();
    index = filePath + (Object.keys(clientCacheDiff)).sort();
    return pkgCache[index] || index;
  };

  addPackageCache = function(index, data) {
    var cache;
    pkgCache[index] = cache = new Buffer(JSON.stringify(data));
    return cache;
  };

  requestHandler = function(req, res, next) {
    var cache, cacheIndex, clientCacheDiff, file, parsedUrl, requestPath;
    if (req.url === '/mundlejs/require.js') {
      return fs.readFile("" + __dirname + "/client.js", function(error, clientJs) {
        res.writeHead(200, {
          'Content-Type': 'text/javascript'
        });
        return res.end(clientJs);
      });
    } else if ((req.url.search(/^\/mundlejs\//)) > -1) {
      parsedUrl = url.parse(req.url.slice(9), true);
      requestPath = '/' + parsedUrl.pathname.slice(1);
      file = new MundleFile({
        clientPath: requestPath
      });
      clientCacheDiff = parsedUrl.query;
      if ((cache = getPackageCache(file, clientCacheDiff)) instanceof Buffer) {
        res.writeHead(200, {
          'Content-Type': 'text/javascript',
          'Content-Length': cache.length
        });
        return res.end(cache);
      } else {
        cacheIndex = cache;
        return serverRequire(file, clientCacheDiff, function(err, results) {
          cache = addPackageCache(cacheIndex, {
            err: err,
            results: results
          });
          res.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Content-Length': cache.length
          });
          return res.end(cache);
        });
      }
    } else {
      return typeof next === "function" ? next() : void 0;
    }
  };

  serverRequire = function(file, loadedModules, callback) {
    var mundle;
    mundle = new Mundle(loadedModules);
    if (!(file instanceof MundleFile)) {
      file = new MundleFile({
        clientPath: file
      });
    }
    return mundle.require(file, callback);
  };

  serverRequire.setBasePath = function(relPath) {
    return basePath = path.resolve(relPath);
  };

  serverRequire.setBasePath('./');

  serverRequire.listen = function(server, options, callback) {
    var port;
    if ('function' === typeof options) {
      callback = options;
      options = {};
    }
    if ('undefined' === typeof server) {
      server = 80;
    }
    if ('number' === typeof server) {
      port = server;
      if (options && options.key) {
        server = require('https').createServer(options);
      } else {
        server = require('http').createServer();
      }
      server.on('request', function(req, res) {
        if ((req.url.search(/^\/mundlejs\//)) === -1) {
          res.writeHead(200);
          return res.end('Welcome to Mundlejs!');
        }
      });
      server.listen(port, callback);
    }
    server.on('request', requestHandler);
    return server;
  };

  serverRequire.connect = function(basePath) {
    if (basePath != null) {
      serverRequire.setBasePath(basePath);
    }
    return requestHandler;
  };

  serverRequire.use = function(plugins) {
    var compiler, extension, extensions, plugin, _i, _len, _results;
    if (!(plugins instanceof Array)) {
      plugins = [plugins];
    }
    _results = [];
    for (_i = 0, _len = plugins.length; _i < _len; _i++) {
      plugin = plugins[_i];
      extensions = plugin.extensions, compiler = plugin.compiler;
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = extensions.length; _j < _len1; _j++) {
          extension = extensions[_j];
          _results1.push(loadedPlugins[extension] = compiler);
        }
        return _results1;
      })());
    }
    return _results;
  };

  module.exports = serverRequire;

}).call(this);
