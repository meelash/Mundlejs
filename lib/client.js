// Generated by CoffeeScript 1.6.2
(function() {
  var Module, baseModule, basePrefix, cache, cacheDiffString, cacheVersion, mundlePrefix, parent, requestHostname, requestPort, require, requireBase, requireMundle, resolveBasePath, resolveMundlePath, serverRequire, updateMundleVersion,
    __hasProp = {}.hasOwnProperty;

  basePrefix = '/b';

  mundlePrefix = '/m';

  Module = (function() {
    function Module(path) {
      this.path = path;
      this.exports = {};
    }

    Module.prototype.runInContext = function(source) {
      var exports, module, require;

      module = this;
      exports = module.exports;
      require = module.require.bind(module);
      eval(source);
      return module.exports;
    };

    Module.prototype.require = function(path, callback) {
      if (/^(\.|\.\.)?\//.test(path)) {
        path = resolveBasePath(path, parent(this.path));
        return requireBase(path, callback);
      } else {
        path = resolveMundlePath(path);
        return requireMundle(path, callback);
      }
    };

    return Module;

  })();

  baseModule = new Module("" + basePrefix + "/");

  window.require = require = baseModule.require.bind(baseModule);

  requestHostname = window.location.hostname;

  requestPort = window.location.port;

  serverRequire = function(path, callback) {
    var request;

    request = new XMLHttpRequest();
    request.open('GET', "//" + requestHostname + ":" + requestPort + "/mundlejs" + path + "?" + (cacheDiffString()), true);
    request.responseType = 'text';
    request.onload = function() {
      var response;

      response = JSON.parse(request.response);
      return callback(response.err, response.results);
    };
    return request.send();
  };

  requireBase = function(path, callback) {
    var exported, source,
      _this = this;

    if ((exported = cache.modules[path]) != null) {
      if (typeof callback === "function") {
        callback(null, exported);
      }
      return exported;
    } else if ((source = cache.fetched[path]) != null) {
      return (function() {
        var module;

        module = new Module(path);
        exported = cache.modules[path] = module.runInContext(source);
        if (typeof callback === "function") {
          callback(null, exported);
        }
        return exported;
      })();
    } else {
      return serverRequire(path, function(errors, sources) {
        var err, subPath, _i, _len;

        if (errors != null) {
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            err = errors[_i];
            if (err != null) {
              console.warn(err);
            }
          }
        }
        for (subPath in sources) {
          if (!__hasProp.call(sources, subPath)) continue;
          source = sources[subPath];
          cache.fetched[subPath] = source;
        }
        return typeof callback === "function" ? callback(null, requireBase(path)) : void 0;
      });
    }
  };

  requireMundle = function(path, callback) {
    var exported, source,
      _this = this;

    if ((exported = cache.modules[path]) != null) {
      if (typeof callback === "function") {
        callback(null, exported);
      }
      return exported;
    } else if ((source = cache.fetched[path]) != null) {
      return (function() {
        var module;

        module = new Module(path);
        exported = cache.modules[path] = module.runInContext(source);
        if (typeof callback === "function") {
          callback(null, exported);
        }
        return exported;
      })();
    } else {
      return serverRequire(path, function(errors, sources) {
        var err, subPath, _i, _len;

        if (errors != null) {
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            err = errors[_i];
            if (err != null) {
              console.warn(err);
            }
          }
        }
        for (subPath in sources) {
          if (!__hasProp.call(sources, subPath)) continue;
          source = sources[subPath];
          cache.fetched[subPath] = source;
          cacheVersion(subPath);
        }
        path = updateMundleVersion(path);
        return typeof callback === "function" ? callback(null, requireMundle(path)) : void 0;
      });
    }
  };

  resolveBasePath = function(path, parentPath) {
    var component, components;

    if (/^\//.test(path)) {
      return path = "" + basePrefix + path;
    } else {
      components = path.split('/');
      path = parentPath;
      while (components.length > 0) {
        switch (component = (components.splice(0, 1))[0]) {
          case '..':
            path = parent(path);
            break;
          case '.':
            break;
          default:
            path += "/" + component;
        }
      }
      return path;
    }
  };

  resolveMundlePath = function(path) {
    var match, subDir, version;

    match = /^(.*?)((@)(.*?))?(\/.*)?$/.exec(path);
    version = match[4] || cache.versions[match[1]] || '0.0.0';
    path = "" + mundlePrefix + "/" + match[1] + "/" + version;
    if ((subDir = match[5]) != null) {
      path += subDir;
    }
    return path;
  };

  updateMundleVersion = function(path) {
    var match, subDir, version;

    match = /^(\/m\/(.*?)\/)(.*?)(\/.*)?$/.exec(path);
    if ((version = match[3]) === '0.0.0') {
      version = cache.versions[match[2]] || '0.0.0';
    }
    path = match[1] + version;
    if ((subDir = match[4]) != null) {
      path += subDir;
    }
    return path;
  };

  parent = function(path) {
    var ar;

    ar = path.split('/');
    if (ar[0] !== '') {
      console.error('parent only accepts absolute paths');
    }
    if (ar[1] === 'm') {
      if (ar.length < 5) {
        return ar.join('/');
      }
    } else if (ar.length < 3) {
      return ar.join('/');
    }
    ar.pop();
    return ar.join('/');
  };

  cacheDiffString = function() {
    return ((Object.keys(cache.fetched)).join('=1&')) + '=1';
  };

  cacheVersion = function(path) {
    var match, mundle, version, _ref;

    if ((match = /\/m\/(.*?)\/(.*?)(\/.*)?$/.exec(path)) != null) {
      _ref = match, match = _ref[0], mundle = _ref[1], version = _ref[2];
      return cache.versions[mundle] = version;
    }
  };

  cache = {
    modules: {},
    fetched: {},
    versions: {}
  };

}).call(this);
